# 混合云架构文件存储与网络部署方案 (Unified API Mode)

## 1. 业务背景与核心决策

当前 SERC 财税系统（is-vue-admin）需要管理大量出口业务凭证（报关单、提单、现场照片等）。
为降低开发复杂度与运维难度，决定采用 **全链路 API 统一调用模式**。

- **核心策略**：无论后端服务运行在**公司内网 Docker** 还是**阿里云**，均通过 **群晖 File Station API** 进行文件读写。
- **优势**：
    1.  **代码唯一**：后端仅维护一套存储逻辑，无需处理 SMB 挂载、文件权限、路径映射等复杂运维问题。
    2.  **环境解耦**：Docker 容器变为无状态（Stateless），可随意迁移部署。
    3.  **内网加速**：内网环境配置内网 IP，依然享受千兆局域网传输速度。

## 2. 核心架构设计

### 2.1 逻辑架构图

```mermaid
graph TD
    User[用户] -->|HTTPS| Nginx[Nginx 网关]
    Nginx --> API_Service[后端 API 服务 (Python)]
    
    subgraph "存储交互层 (统一接口)"
        API_Service -->|HTTP/HTTPS 请求| Synology_API[群晖 File Station API]
    end

    subgraph "群晖 NAS (单一数据源)"
        Synology_API --> FS[文件系统 /volume1/serc_files]
    end

    %% 环境差异配置
    note[环境配置差异]
    note -.->|内网部署| Env_Local[NAS_URL = http://192.168.1.50:5000]
    note -.->|云端部署| Env_Cloud[NAS_URL = https://nas.jzb.com:5001]
```

---

## 3. 详细实施方案

### 3.1 群晖 NAS 准备工作

1.  **启用功能**：
    *   **File Station**：确保已安装并启用。
    *   **用户权限**：创建一个专用账号（如 `serc_api_user`），仅授予 `/serc_files` 文件夹的读写权限（禁止访问其他私有数据）。
2.  **网络配置**：
    *   **内网**：固定 NAS IP 地址（如 `192.168.1.50`）。
    *   **外网**：配置 DDNS（如 `xx.synology.me`）并在路由器做端口映射（5000/5001）。

### 3.2 后端服务层 (Python)

**无需任何 Volume 挂载**，仅需封装一个通用的群晖客户端类。

#### 3.2.1 环境变量配置 (.env)

不同环境仅需修改 `NAS_HOST`：

```bash
# === 内网环境 (docker-compose.yml) ===
NAS_HOST=http://192.168.1.50:5000
NAS_USER=serc_api_user
NAS_PASSWORD=your_secure_password

# === 云端环境 (k8s / aliyun) ===
NAS_HOST=https://nas.jzb.com:5001  # 走公网 HTTPS
NAS_USER=serc_api_user
NAS_PASSWORD=your_secure_password
```

#### 3.2.2 核心代码逻辑 (伪代码)

```python
import requests
import os

class SynologyStorage:
    def __init__(self):
        self.base_url = os.getenv('NAS_HOST')
        self.session = requests.Session()
        self._sid = None
    
    def login(self):
        """获取 SID (Session ID)"""
        # 调用 /webapi/auth.cgi
        # 实际开发建议使用 'synology-api' 第三方库简化
        pass

    def upload_file(self, file_obj, dest_path):
        """统一上传接口"""
        if not self._sid: self.login()
        
        # 调用 /webapi/FileStation/upload.cgi
        url = f"{self.base_url}/webapi/entry.cgi"
        params = {
            'api': 'SYNO.FileStation.Upload',
            'version': '2',
            'method': 'upload',
            '_sid': self._sid,
            'path': dest_path,
            'create_parents': 'true'
        }
        files = {'file': file_obj}
        return self.session.post(url, data=params, files=files)

    def download_file(self, file_path):
        """统一下载接口"""
        # 调用 /webapi/FileStation/Download
        pass
```

### 3.3 网络接入层 (Nginx 分流)

依然保留 **DNS 智能分流** 的设计，以保证用户访问前端应用的速度。

*   **内网用户**：`api.serc.com` -> 解析到内网服务器 IP。
*   **外网用户**：`api.serc.com` -> 解析到阿里云公网 IP。

---

## 4. 运维与开发优势总结

1.  **极大简化 Docker 配置**：
    *   旧方案：`volumes: - /mnt/nas:/app/media` (需要宿主机先挂载，易出错)。
    *   **新方案**：完全不需要 volumes 配置。
2.  **安全性提升**：
    *   后端服务器不需要拥有 NAS 的底层文件系统权限 (Root/Admin)，仅通过 API 账号受限访问，即使后端被攻破，NAS 依然安全。
3.  **排错容易**：
    *   文件传不上去？直接用 Postman 调一下群晖 API 就能排查，不用去查 Linux 挂载点掉没掉。

## 5. 推荐开发库

为了避免重复造轮子，建议后端直接集成成熟的 Python 库：
*   **synology-api**: `pip install synology-api`
    *   已有现成的 `filestation.upload_file()` 方法，开箱即用。
