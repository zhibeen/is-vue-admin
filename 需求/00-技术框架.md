# 技术框架选型

## 1. 架构模式
- **模式**: 前后端分离
- **交互方式**: RESTful API (JSON)

## 2. 前端 (Frontend)
- **核心框架**: [Vben Admin 5.0](https://github.com/vbenjs/vue-vben-admin)
  - **版本**: v5 (基于 Turborepo 的 Monorepo 架构)
  - **UI 组件库**: **Ant Design Vue** (深度整合版)
    - *选择理由*: 适合复杂中后台，组件丰富，Vben 官方原生支持最好。
  - **状态管理**: Pinia
  - **路由管理**: Vue Router
- **开发语言**: TypeScript
- **构建工具**: Vite
- **包管理器**: pnpm (推荐, version >= 9)
- **运行环境**: 本地 Node.js (v20+) 环境 (不使用 Docker，以便利用 HMR 热更新)

## 3. 后端 (Backend)
- **开发语言**: Python 3.10+
- **Web 框架**: [APIFlask](https://github.com/apiflask/apiflask)
  - 优势: 自动生成 OpenAPI 文档，内置请求验证。
- **认证方案 (Authentication)**:
  - **方式**: Bearer Token (JWT)
  - **库**: `flask-jwt-extended` + `APIFlask.HTTPTokenAuth`
  - **流程**:
    1. `/auth/login` (POST JSON) -> 获取 Access Token。
    2. 后续请求 Header 携带 `Authorization: Bearer <Token>`。
    3. 后端通过 `@auth.verify_token` 委托给 `verify_jwt_in_request` 进行校验。
  - **API 文档**:
    - 使用 APIFlask 原生 `HTTPTokenAuth`，自动生成 OpenAPI 安全定义。
    - **关键配置**: 实例化时仅使用 `HTTPTokenAuth(scheme='Bearer')`，**严禁**手动指定 `header='Authorization'` 参数。
      - *原因*: 指定 header 参数会导致 OpenAPI 将其识别为 `apiKey` 模式，Swagger UI 不会自动添加 `Bearer ` 前缀；不指定则默认为 `http/bearer` 模式，Swagger UI 会处理前缀。
- **API 路由管理 (Blueprints)**:
  - **版本控制**: 使用嵌套 Blueprint (`api_v1` 作为父级)，统一管理 `/api/v1` 前缀。
  - **目录结构**: 按业务领域模块化拆分 (Domain-Driven Design 风格)。
    ```text
    backend/app/api/
    ├── __init__.py          # 定义 api_v1 并注册子模块
    ├── auth/                # 认证模块
    │   └── routes.py
    └── product/             # 商品业务域
        ├── routes.py        # 商品核心接口 (/products)
        ├── category.py      # 分类接口 (/categories)
        └── vehicle.py       # 车型接口 (/vehiclesaux)
    ```
- **数据库**: PostgreSQL (v15+)
  - **地址**: `pgm-bp14ze6w2u23d65bco.pg.rds.aliyuncs.com`
  - **连接方式**: SQLAlchemy 2.0 ORM
- **ORM (对象关系映射)**: [SQLAlchemy 2.0](https://www.sqlalchemy.org/)
  - **代码风格**: **Declarative Mapping (Mapped Class)**
  - **写法**: 使用 `Mapped[]` 和 `mapped_column()` 进行强类型定义。
  - **驱动**: `psycopg2-binary`
- **数据迁移**: Alembic (必选)
  - 作用: 管理数据库版本变更，禁止手动修改数据库表结构。

## 4. 开发环境与部署 (DevOps)
- **开发模式**:
  - **后端**: 本地 Docker (推荐) 或 本地 venv。
  - **前端**: 本地 Node 环境运行。
  - **数据库**: 阿里云 RDS (远程连接)。
- **容器化**: Docker & Docker Compose (仅后端)
  - **特点**: 多阶段构建 (Multi-stage Build)
    - `builder`: 编译依赖。
    - `final`: 基于 slim 镜像，仅复制 wheel 包，极致轻量。

## 5. 项目目录结构 (Monorepo)

```text
is-vue-admin/
├── backend/                   # 后端 (Python/APIFlask)
│   ├── app/
│   │   ├── __init__.py        # App 工厂函数 (配置 Auth, CORS, APIFlask, Celery)
│   │   ├── celery_utils.py    # Celery 工厂函数
│   │   ├── tasks.py           # 异步任务定义
│   │   ├── logging_config.py  # 日志配置文件
│   │   ├── decorators.py      # 权限控制装饰器 (RBAC)
│   │   ├── errors.py          # 统一异常类
│   │   ├── extensions.py      # 扩展 (DB, JWT等)
│   │   ├── security.py        # 认证回调逻辑 (HTTPTokenAuth)
│   │   ├── models/            # SQLAlchemy 2.0 Models
│   │   ├── services/          # 业务逻辑层 (Service Layer)
│   │   ├── api/               # API 路由 (模块化结构)
│   │   │   ├── __init__.py    # v1 版本控制
│   │   │   ├── auth/          # 认证相关
│   │   │   └── product/       # 产品/分类/车型相关
│   │   └── schemas/           # 数据验证模式
│   ├── logs/                  # 日志文件存储 (按天切割)
│   ├── migrations/            # Alembic 迁移文件
│   ├── requirements.txt       # 依赖列表 (含 celery, redis, pytest)
│   ├── Dockerfile             # 后端镜像构建 (Multi-stage)
│   ├── config.py              # 配置类
│   └── run.py                 # 启动入口
│   ├── tests/                 # 自动化测试目录
│       ├── conftest.py
│       ├── factories.py
│       ├── api/
│       └── unit/
│
├── frontend/                  # 前端 (Vben Admin 5.0 Monorepo)
│   ├── apps/
│   │   └── web-antd/          # 主应用 (Ant Design Vue 版)
│   ├── packages/              # 共享包 (API, Hooks, Utils)
│   ├── pnpm-workspace.yaml    # 工作区配置
│   └── turbo.json             # 构建管道配置
│
├── 需求/                      # 项目文档
├── docker-compose.yml         # 后端服务编排 (Redis + Web + Worker)
├── env_config                 # 环境变量模板 (需复制为 .env)
├── README.md                  # 开发环境启动指南
└── .gitignore
```

## 6. 数据库连接配置
- **Host**: `pgm-bp14ze6w2u23d65bco.pg.rds.aliyuncs.com`
- **User**: `zhibeen`
- **Password**: `Eade2025+`
- **ORM Style**: SQLAlchemy 2.0 Mapped Class

## 7. 多设备同步与 Git 工作流
详见上文，采用 Git 同步代码，连接统一远程数据库。

## 8. 单人开发效率优化
- **前端代码自动生成**: 依据后端 OpenAPI 文档自动生成 TypeScript 接口。
- **CORS**: 后端已开启跨域。
- **工具链**: 后端使用 Ruff，前端使用 ESLint + Prettier。

## 9. API 开发规范 (API Standards)

为保证代码风格统一和文档质量，后续开发请遵循以下规范。

### 9.1 视图编写范本 (MethodView 推荐)

后续新功能模块推荐使用 **基于类的视图 (Class-Based Views)**，使用 `apiflask.views.MethodView`。这种方式更适合 RESTful 资源的管理。

**重要**: 使用 `@input` 装饰器时，建议显式指定 `arg_name`，以避免参数注入错误（特别是在测试环境下）。
例如: `@bp.input(Schema, arg_name='data')`，则处理函数必须定义 `def func(data):`。

**范本代码**:

```python
from apiflask import APIBlueprint, Schema
from apiflask.views import MethodView
from apiflask.fields import String, Integer
from app.extensions import db
from app.security import auth

# 1. 定义 Blueprint
demo_bp = APIBlueprint('demo', __name__, url_prefix='/demo', tag='DemoResource')

# 2. 定义 MethodView
class DemoListAPI(MethodView):
    # 统一应用装饰器 (如认证)
    decorators = [demo_bp.auth_required(auth)]
    
    @demo_bp.doc(summary='获取列表', description='获取 Demo 资源列表')
    @demo_bp.output(DemoSchema(many=True))
    def get(self):
        """List items"""
        return []

    @demo_bp.doc(summary='创建资源', description='创建新的 Demo 资源')
    @demo_bp.input(DemoSchema, arg_name='data') # 显式指定参数名
    @demo_bp.output(DemoSchema, status_code=201)
    def post(self, data): # 参数名与 arg_name 一致
        """Create item"""
        return data

class DemoItemAPI(MethodView):
    decorators = [demo_bp.auth_required(auth)]

    @demo_bp.doc(
        summary='获取详情', 
        description='根据 ID 获取资源详情'
    )
    @demo_bp.output(DemoSchema)
    def get(self, item_id):
        """Get item"""
        return {}

    @demo_bp.doc(summary='更新资源')
    @demo_bp.input(DemoSchema)
    @demo_bp.output(DemoSchema)
    def put(self, item_id, data):
        """Update item"""
        return data

    @demo_bp.doc(summary='删除资源')
    def delete(self, item_id):
        """Delete item"""
        return '', 204

# 3. 注册路由
demo_bp.add_url_rule('/', view_func=DemoListAPI.as_view('list_items'))
demo_bp.add_url_rule('/<int:item_id>', view_func=DemoItemAPI.as_view('item_resource'))
```

### 9.2 文档注释要求 (OpenAPI)
所有 API 方法必须包含 `@doc` 装饰器，以生成清晰的 Swagger 文档。

- **Summary**: 简短的中文标题 (e.g. `summary='获取商品列表'`)。
- **Description**: 详细的功能描述，包含业务逻辑说明。

### 9.3 Schema 定义要求
所有 Marshmallow/APIFlask Schema 字段必须包含 `metadata` 用于文档展示。

```python
name = String(
    required=True, 
    metadata={'description': '商品名称', 'example': 'iPhone 15'}
)
```

## 10. 后端代码优化规范 (Backend Optimization Standards)

为保证系统的高性能和可维护性，必须遵循以下优化规范。

### 10.1 Service 层模式 (Business Logic Layer)
**原则**: 禁止在 `routes.py` 中编写复杂的业务逻辑（如事务控制、复杂计算、多表操作）。所有业务逻辑必须封装在 `app/services/` 目录下。

**结构**:
- `routes.py`: 仅负责请求参数解析、调用 Service、返回响应。
- `services/*.py`: 负责具体的业务逻辑、数据库操作、异常抛出。

**示例**:
```python
# services/product_service.py
class ProductService:
    def create_product(self, data):
        # 业务逻辑...
        return product
```

### 10.2 数据库查询优化 (N+1 Problem)
**原则**: 严禁在循环中进行数据库查询。必须使用 SQLAlchemy 的 Eager Loading 机制。

**方案**:
- 使用 `selectinload` 加载一对多/多对多关联。
- 使用 `joinedload` 加载多对一/一对一关联。

**示例**:
```python
stmt = select(Product).options(selectinload(Product.category))
```

### 10.3 分页与搜索规范 (Pagination & Search)
**原则**: 列表接口必须支持分页和通用搜索，禁止全量返回。

**方案**:
- **Schema**: 使用 `PaginationQuerySchema` 接收 `page`, `per_page`, `q` (关键词), `sort` (排序)。
- **Service**: 实现通用过滤逻辑，支持模糊搜索 (ilike) 和动态排序。
- **Response**: 使用 `PaginationSchema` 统一返回结构。

### 10.4 统一异常处理 (Error Handling)
**原则**: 业务层使用 `app.errors.BusinessError` 抛出异常，由框架统一捕获，禁止在视图层随意 `abort` 且不记录日志。

### 10.5 权限控制规范 (Permission-Based Access Control)
**原则**: 采用**基于权限 (Permission-Based)** 的细粒度控制，而非简单的基于角色 (Role-Based)。这使得权限分配更加灵活，无需修改代码即可动态配置角色的权限。

**模型设计**:
- **Permission**: 原子权限 (e.g., `product:create`, `vehicle:manage`)。
- **Role**: 角色 (e.g., `admin`, `editor`)，包含一组 Permission。
- **User**: 用户，包含一组 Role。
- **Token Claims**: JWT 中携带 `permissions` 列表，用于前后端鉴权。

**使用方案**:
- 使用 `@permission_required('perm_name')` 装饰器。
- 示例:
  ```python
  @bp.delete('/<id>')
  @permission_required('product:delete')
  def delete_item(id): ...
  ```

## 11. 日志与监控系统 (Logging & Monitoring)

我们采用了结构化日志（JSON）+ 文件轮转的方案，既方便开发调试，又无缝对接云端日志服务。

### 11.1 本地日志策略
- **开发环境 (stdout)**: 控制台输出彩色日志，格式易读。
- **生产环境 (file)**: 输出 JSON 格式日志到 `backend/logs/app.log`。
  - **自动切割**: 每天午夜自动生成新文件 (e.g., `app.log.2023-10-27`)。
  - **保留周期**: 本地保留 30 天，过期自动删除。
  - **包含字段**: `timestamp`, `level`, `module`, `message`, `user_id`, `request_id`, `duration` 等。

### 11.2 阿里云日志服务 (SLS) 对接指南
生产环境下，推荐使用 **Logtail 采集** 模式，对业务代码**零侵入**。

#### 步骤一：准备工作
1. 在阿里云控制台开通 **日志服务 (SLS)**。
2. 创建 **Project** (e.g., `is-admin-prod`) 和 **Logstore** (e.g., `backend-logs`)。
3. 在 ECS 服务器上安装 **Logtail** (阿里云提供一键安装命令)。

#### 步骤二：配置 Logtail 采集配置
1. 进入 Logstore -> 数据接入 -> **JSON - 文本日志**。
2. **日志路径**: 填写容器挂载到宿主机的日志目录，例如 `/var/log/is-admin/backend/*.log`。
   - *注意*: 确保 Docker 启动时使用了 Volume 挂载: `-v /host/logs:/app/logs`。
3. **模式**: 选择 **JSON 模式**。Logtail 会自动解析 JSON 字段。
4. **时间解析**: 选择 `timestamp` 字段作为日志时间。

#### 步骤三：查询与分析
配置完成后，日志会自动上传至 SLS。你可以：
- 使用 SQL 语法查询：`status > 500 | select count(1) as error_count`
- 根据 `request_id` 全链路追踪问题。
- 设置告警规则（如每分钟 Error 超过 10 个发送钉钉通知）。

## 12. 部署与架构演进路线 (Deployment Roadmap)

基于项目发展阶段，我们制定了分阶段的部署策略。

### 12.1 阶段一：本地开发 (Local Dev)
- **场景**: 单人/小团队功能迭代。
- **架构**:
  - PC 运行后端 (Docker Compose) + 前端 (Node)。
  - 数据库连接远程阿里云 RDS (开发库)。
  - **启动方式**: `flask run --debug` (热重载，通过 docker-compose.yml 覆盖默认 CMD)。
- **关键技术**: Docker Volume 挂载源码。
- **数据持久性**:
  - 由于使用了**独立的阿里云 RDS**，开发环境采用了**计算与存储分离**的架构。
  - **Docker 容器重建** (`docker compose down && up`) 仅重置计算实例（代码运行环境），**不会影响**数据库中的业务数据。
- **工作流推荐**:
  - **修改代码 (Python)**: 直接保存，Flask 热重载自动生效 (无需重启)。
  - **修改依赖/配置 (requirements.txt, Dockerfile)**: 执行 `docker compose down && docker compose up --build -d`。这是合理且正确的方案，确保环境纯净且数据安全。

### 12.2 阶段二：首次上线 (Initial Launch)
- **场景**: 内部试用 / 小规模公测。
- **架构**: **单体 ECS (云服务器)**。
  - 购买一台 ECS (e.g. 2核4G)。
  - 部署方式: `Docker Compose`。
    - 后端服务 (使用 Dockerfile 默认的 **Gunicorn** 启动，高性能)。
    - Nginx (反向代理 + 静态资源)。
    - Redis (缓存 & 消息队列)。
  - 数据库: 继续使用阿里云 RDS (生产库)。
  - 异步队列: 使用 Docker Compose 中的 `redis` 和 `celery_worker` 服务。
- **优势**: 部署简单，成本低，与开发环境高度一致，排查问题方便。

### 12.3 阶段三：规模化扩展 (Scaling Phase)
- **场景**: 业务增长，流量增加，对高可用有要求。
- **架构**: **阿里云 SAE (Serverless) + 独立 RDS/Redis**。
  - **应用层**: 迁移至 **SAE (Serverless App Engine)**。
    - **Web 实例**: 配置 Gunicorn 启动，处理 API 请求。
    - **Worker 实例**: 独立部署，配置 `celery worker` 启动，处理异步任务。
    - 优势: 免运维、秒级自动扩缩容、灰度发布。
  - **数据层**: 独立的 RDS PostgreSQL (主备高可用) + 云数据库 Redis。
  - **静态资源**: 前端构建产物部署至 **OSS + CDN**。
- **优势**: 极致弹性，运维成本极低，稳定性高。

## 13. 自动化测试体系 (Testing Strategy)

为保证代码质量和重构安全性，项目引入了完整的自动化测试体系。

### 13.1 技术栈
- **核心框架**: `pytest`
- **数据工厂**: `factory_boy` (基于 SQLAlchemy 模型自动生成测试数据) + `Faker`
- **覆盖率**: `pytest-cov`
- **Flask 集成**: `pytest-flask`

### 13.2 测试架构与模式
- **数据库策略**: 使用 **SQLite 内存数据库** (`sqlite:///:memory:`) 进行极速测试。
- **事务回滚**: 每个测试用例运行在独立的数据库事务中，测试结束后自动回滚，保证环境纯净。
- **JSONB 兼容**: 通过 `conftest.py` 中的 Monkey Patch，让 SQLite 能够处理 PostgreSQL 的 `JSONB` 类型（自动降级为 `JSON`）。
- **目录结构**:
  ```text
  backend/tests/
  ├── conftest.py          # 全局 Fixture (App, Client, DB Session, AdminUser)
  ├── factories.py         # 数据工厂 (UserFactory, ProductFactory)
  ├── api/                 # 集成测试 (测试 API 接口权限、逻辑)
  └── unit/                # 单元测试 (测试 Service 层复杂算法)
  ```

### 13.3 常用命令
- **运行所有测试**:
  ```bash
  # 在 Docker 中运行 (推荐)
  docker compose exec backend env PYTHONPATH=/app pytest
  ```
- **运行特定测试文件**:
  ```bash
  docker compose exec backend env PYTHONPATH=/app pytest tests/api/test_auth.py
  ```
- **查看覆盖率报告**:
  ```bash
  docker compose exec backend env PYTHONPATH=/app pytest --cov=app
  ```

## 14. 异步任务架构 (Async Task Queue)

为解决耗时操作（如导出、发邮件）导致的请求超时问题，引入了 Celery 分布式任务队列。

### 14.1 架构组件
- **Broker**: **Redis** (消息中间件，负责存取任务)。
- **Worker**: **Celery Worker** (后台进程，负责执行任务)。
- **Producer**: **Flask API** (生产者，负责派发任务)。

### 14.2 代码实现
- **任务定义**: `backend/app/tasks.py` 使用 `@shared_task`。
- **任务调用**: `task.delay(arg1, arg2)`。
- **初始化**: 在 `create_app` 中通过 `celery_init_app` 绑定 Flask 上下文。

## 15. 待实施架构演进 (Future Roadmap - Pending Implementation)

本章节列出的方案目前**尚未实装**。这些是为未来大规模业务场景准备的架构升级计划，属于企业级标准的高级特性。

### 15.1 API 限流 (Rate Limiting)
- **当前状态**: 未实施
- **实施时机**:
  - 当 API 每日调用量超过 10万次。
  - 或遭遇第一次 CC 攻击/爬虫暴力破解时。
  - 或系统开放公网注册，存在被恶意刷库风险时。
- **技术方案**:
  - **库**: `Flask-Limiter`
  - **存储**: 复用现有的 Redis。
  - **代码示例**:
    ```python
    from flask_limiter import Limiter
    from flask_limiter.util import get_remote_address
    
    limiter = Limiter(
        key_func=get_remote_address,
        storage_uri="redis://redis:6379/0"
    )
    
    @auth_bp.route('/login', methods=['POST'])
    @limiter.limit("5 per minute") # 针对登录接口严格限流
    def login(): ...
    ```

### 15.2 软删除 (Soft Delete)
- **当前状态**: 未实施 (目前采用物理删除)
- **实施时机**:
  - 正式上线运营后，需要保留数据审计痕迹时。
  - 防止客服/运营人员误操作导致数据永久丢失时。
- **技术方案**:
  - **Mixin 设计**:
    ```python
    class SoftDeleteMixin:
        deleted_at = db.Column(db.DateTime, nullable=True)
        
        def delete(self):
            self.deleted_at = datetime.now()
            db.session.add(self)
            
        @classmethod
        def query_active(cls):
            return cls.query.filter_by(deleted_at=None)
    ```
  - **迁移工作**: 需要为所有表添加 `deleted_at` 字段 (Alembic 迁移)。

### 15.3 代码质量门禁 (Pre-commit Hooks)
- **当前状态**: 未实施 (仅建议本地安装 Ruff)
- **实施时机**:
  - 开发团队扩充至 2 人以上时。
  - 代码风格开始出现不一致（如引号混用、缩进混乱）时。
- **技术方案**:
  - **工具**: `pre-commit`
  - **配置**: `.pre-commit-config.yaml`
    ```yaml
    repos:
      - repo: https://github.com/astral-sh/ruff-pre-commit
        rev: v0.1.0
        hooks:
          - id: ruff
            args: [ --fix, --exit-non-zero-on-fix ]
    ```

### 15.4 全链路追踪 (Observability / Distributed Tracing)
- **当前状态**: 未实施 (仅有基础 Request ID)
- **实施时机**:
  - 引入微服务架构或调用链路变得极度复杂时。
  - 发现某些异步任务 (Celery) 报错无法定位是由哪个 Web 请求触发时。
- **技术方案**:
  - **Request ID 透传**:
    1. Flask Middleware 生成 `X-Request-ID`。
    2. 存入 `flask.g`。
    3. 调用 Celery 时: `task.apply_async(..., headers={'X-Request-ID': g.request_id})`。
    4. Celery Worker 读取 Header 并注入日志上下文。


